# 16. PL/SQL
## 실행 결과를 화면에 출력
+ 대입 연산자 (:=)
+ ||는 자바에서 + 역할
```
SET SERVEROUTPUT ON;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello PL/SQL');
END;
/
-- 변수, 상수, DEFAULT, NOT NULL 선언

DECLARE
    V_EMPNO NUMBER(4) := 7788;
    V_ENAME VARCHAR2(10);
    V_TEX CONSTANT NUMBER(1) := 3;
    V_DEPTNO NUMBER(2) DEFAULT 10;
    V_DEPTNO2 NUMBER(2) NOT NULL := 10;
    V_DEPTNO3 NUMBER(2) NOT NULL DEFAULT 10;
BEGIN
    V_ENAME := 'SCOTT';
    DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
    DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
    DBMS_OUTPUT.PUT_LINE('V_TEX : ' || V_TEX);
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO : ' || V_DEPTNO);
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO2 : ' || V_DEPTNO2);
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO3 : ' || V_DEPTNO3);
END;
/

```

## 변수의 자료형
> 참조형의 변수에 값을 대입한 후 출력하기
```
DECLARE
    V_EMPNO EMP.EMPNO%TYPE := 7788;
    V_ENAME EMP.ENAME%TYPE;
    V_TEX CONSTANT NUMBER(1) := 3;
    V_DEPTNO3 EMP.DEPTNO%TYPE NOT NULL DEFAULT 10;
    V_EMP_ROW EMP%ROWTYPE;
BEGIN
    V_ENAME := 'SCOTT';
    SELECT * INTO V_EMP_ROW
    FROM EMP WHERE EMPNO = 7839;
    DBMS_OUTPUT.PUT_LINE('EMPNO : ' || V_EMP_ROW.EMPNO);
    DBMS_OUTPUT.PUT_LINE('ENAME : ' || V_EMP_ROW.ENAME);
     DBMS_OUTPUT.PUT_LINE('JOB : ' || V_EMP_ROW.JOB);
     DBMS_OUTPUT.PUT_LINE('MGR : ' || V_EMP_ROW.MGR);
END;
/

SELECT * FROM EMP;
```


## 16-3 조건 제어문
```
DECLARE
    V_NUMBER NUMBER := 14;
BEGIN
    IF(MOD(V_NUMBER, 2) = 1) THEN
        DBMS_OUTPUT.PUT_LINE('odd number');
    ELSE
         DBMS_OUTPUT.PUT_LINE('even number');
    END IF;
END;
/
```
+ ELSIF
```
DECLARE
    V_NUMBER NUMBER := 87;
BEGIN
    IF V_NUMBER >= 90 THEN
        DBMS_OUTPUT.PUT_LINE('A GRADE');
    ELSIF V_NUMBER >= 80 THEN
         DBMS_OUTPUT.PUT_LINE('B GRADE');
    ELSIF V_NUMBER >= 70 THEN
        DBMS_OUTPUT.PUT_LINE('C GRADE');
    ELSE
        DBMS_OUTPUT.PUT_LINE('F GRADE');
    END IF;
END;
/
```
+ CASE문
```
DECLARE
    V_NUMBER NUMBER := 87;
BEGIN
    CASE TRUNC(V_NUMBER /10)
    WHEN 10 THEN DBMS_OUTPUT.PUT_LINE('A GRADE');
    WHEN 9 THEN DBMS_OUTPUT.PUT_LINE('B GRADE');
    WHEN 8 THEN DBMS_OUTPUT.PUT_LINE('C GRADE');
    ELSE DBMS_OUTPUT.PUT_LINE('F GRADE');
    END CASE;
END;
/
```
+ LOOP문
```
DECLARE
    V_NUMBER NUMBER := 0;
BEGIN
    LOOP
        DBMS_OUTPUT.PUT_LINE('V_NUMBER : ' || V_NUMBER);
        V_NUMBER := V_NUMBER + 1;
        EXIT WHEN V_NUMBER > 4;
    END LOOP;
END;
/
```
+ WHILE LOOP
```
DECLARE
    V_NUMBER NUMBER := 0;
BEGIN
    WHILE V_NUMBER < 4 LOOP
        DBMS_OUTPUT.PUT_LINE('V_NUMBER : ' || V_NUMBER);
        V_NUMBER := V_NUMBER + 1;
    END LOOP;
END;
/

-- FOR LOOP
BEGIN
    FOR I IN 0..4 LOOP
        DBMS_OUTPUT.PUT_LINE('I : ' || I);
    END LOOP;
END;
/

BEGIN
    FOR I IN REVERSE 0..4 LOOP
        DBMS_OUTPUT.PUT_LINE('I : ' || I);
    END LOOP;
END;
/
```
+ CONTINUE
```
BEGIN
    FOR I IN REVERSE 0..4 LOOP
        CONTINUE WHEN MOD(I, 2) = 1;
         DBMS_OUTPUT.PUT_LINE('I : ' || I);
    END LOOP;
END;
/

```



# 17. 레코드와 컬렉션
## 17-1 자료형이 다른 여러 데이터를 저장하는 레코드
```
SET SERVEROUTPUT ON;
DECLARE
    TYPE REC_DEPT IS RECORD (
        DEPTNO NUMBER(2) NOT NULL := 99,
        DNAME DEPT.DNAME%TYPE,
        LOC DEPT.LOC%TYPE
    );
    REC REC_DEPT;
BEGIN
    REC.DEPTNO := 50;
    REC.DNAME := 'NETWORK';
    REC.LOC := 'BUSAN';
    INSERT INTO DEPT VALUES REC;
    -- UPDATE DEPT SET ROW = REC WHERE DEPTNO = 99;
    DBMS_OUTPUT.PUT_LINE(REC.DEPTNO);
    DBMS_OUTPUT.PUT_LINE(REC.DNAME);
    DBMS_OUTPUT.PUT_LINE(REC.LOC);
END;
/

SELECT * FROM DEPT;
DELETE FROM DEPT WHERE DEPTNO = 50;

-- ROWTYPE 사용하기
SET SERVEROUTPUT ON;
DECLARE
    REC DEPT%ROWTYPE;
BEGIN
    REC.DEPTNO := 99;
    REC.DNAME := 'NETWORK';
    REC.LOC := 'BUSAN';
    -- INSERT INTO DEPT VALUES REC;
    UPDATE DEPT SET ROW = REC WHERE DEPTNO = 50;
    DBMS_OUTPUT.PUT_LINE(REC.DEPTNO);
    DBMS_OUTPUT.PUT_LINE(REC.DNAME);
    DBMS_OUTPUT.PUT_LINE(REC.LOC);
END;
/

SET SERVEROUTPUT ON;
DECLARE
    REC DEPT%ROWTYPE;
BEGIN
    REC.DEPTNO := 70;
    REC.DNAME := 'NETWORK1';
    REC.LOC := 'DAEJEON1';
    INSERT INTO DEPT VALUES REC;
    DBMS_OUTPUT.PUT_LINE(REC.DEPTNO);
    DBMS_OUTPUT.PUT_LINE(REC.DNAME);
    DBMS_OUTPUT.PUT_LINE(REC.LOC);
END;
/
SELECT * FROM DEPT;
```

+ 레코드를 포함하는 레코드
```
SET SERVEROUTPUT ON;
DECLARE
    TYPE REC_DEPT IS RECORD(
        DEPTNO NUMBER(2),
        DNAME DEPT.DNAME%TYPE,
        LOC DEPT.LOC%TYPE
    );
    TYPE REC_EMP IS RECORD (
        EMPNO EMP.EMPNO%TYPE,
        ENAME EMP.ENAME%TYPE,
        DINFO REC_DEPT
    );
    REC REC_EMP;
BEGIN
    SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, D.LOC
        INTO REC.EMPNO, REC.ENAME, REC.DINFO.DEPTNO, REC.DINFO.DNAME, REC.DINFO.LOC
        FROM EMP E JOIN DEPT D
        ON E.DEPTNO = D.DEPTNO
    WHERE E.EMPNO = 7839;
        
    DBMS_OUTPUT.PUT_LINE(REC.EMPNO);
    DBMS_OUTPUT.PUT_LINE(REC.ENAME);
    DBMS_OUTPUT.PUT_LINE(REC.DINFO.DEPTNO);
     DBMS_OUTPUT.PUT_LINE(REC.DINFO.DNAME);
      DBMS_OUTPUT.PUT_LINE(REC.DINFO.LOC);
END;
/
SELECT * FROM DEPT;
```

## 17-2 자료형이 같은 여러 데이터를 저장하는 컬렉션
### 연관 배열
```
SET SERVEROUTPUT ON;
DECLARE
    TYPE EX IS TABLE OF VARCHAR2(20)
    INDEX BY PLS_INTEGER;
    TEXTS EX;
BEGIN
    TEXTS(1) := '1st data';
    TEXTS(2) := '2nd data';
    TEXTS(3) := '3rd data';
    TEXTS(4) := '4th data';
    
    DBMS_OUTPUT.PUT_LINE('TEXTS(1): ' || TEXTS(1));
    DBMS_OUTPUT.PUT_LINE('TEXTS(2): ' || TEXTS(2));
    DBMS_OUTPUT.PUT_LINE('TEXTS(3): ' || TEXTS(3));
    DBMS_OUTPUT.PUT_LINE('TEXTS(4): ' || TEXTS(4));
END;
/
```
### 레코드
```
-- RECORD
DECLARE
    TYPE REC_DEPT IS RECORD (
        DEPTNO DEPT.DEPTNO%TYPE,
        DNAME DEPT.DNAME%TYPE,
        LOC DEPT.LOC%TYPE
        
    );
    TYPE EX IS TABLE OF REC_DEPT
    INDEX BY PLS_INTEGER;
    RECS EX;
    IDX PLS_INTEGER := 0;
BEGIN
    FOR I IN (SELECT * FROM DEPT) LOOP
        IDX := IDX + 1;
        RECS(IDX).DEPTNO := I.DEPTNO;
        RECS(IDX).DNAME := I.DNAME;
        RECS(IDX).LOC := I.LOC;
        DBMS_OUTPUT.PUT_LINE(RECS(IDX).DEPTNO || RECS(IDX).DNAME ||  RECS(IDX).LOC);
    END LOOP;
END;
/

-- ROWTYPE
DECLARE
    TYPE EX IS TABLE OF DEPT%ROWTYPE
    INDEX BY PLS_INTEGER;
    RECS EX;
    IDX PLS_INTEGER := 0;
BEGIN
    FOR I IN (SELECT * FROM DEPT) LOOP
        IDX := IDX + 1;
        RECS(IDX).DEPTNO := I.DEPTNO;
        RECS(IDX).DNAME := I.DNAME;
        RECS(IDX).LOC := I.LOC;
        DBMS_OUTPUT.PUT_LINE(RECS(IDX).DEPTNO || RECS(IDX).DNAME ||  RECS(IDX).LOC);
    END LOOP;
END;
/
-- 복습
DECLARE
    TYPE EX IS TABLE OF DEPT%ROWTYPE
    INDEX BY PLS_INTEGER;
    RECS EX;
    IDX PLS_INTEGER := 0;
BEGIN
    FOR I IN (SELECT * FROM DEPT) LOOP
        IDX := IDX + 1;
        RECS(IDX).DEPTNO := I.DEPTNO;
        RECS(IDX).DNAME := I.DNAME;
        RECS(IDX).LOC := I.LOC;
        DBMS_OUTPUT.PUT_LINE(RECS(IDX).DEPTNO || RECS(IDX).DNAME ||  RECS(IDX).LOC);
        DBMS_OUTPUT.PUT_LINE(RECS.COUNT || ' ' || RECS.FIRST || ' ' || RECS.LAST);
    END LOOP;
END;
/


```

# 18. 커서와 예외 처리
## 커
+ 단일행
```
DECLARE
    RECS DEPT%ROWTYPE;
BEGIN
    SELECT * INTO RECS
    FROM DEPT WHERE DEPTNO = 40;
     DBMS_OUTPUT.PUT_LINE(RECS.DEPTNO || RECS.DNAME ||  RECS.LOC);
END;
/
```
+ 커서
```
DECLARE
    CURSOR C1 IS (SELECT * FROM DEPT);
    REC DEPT%ROWTYPE;
BEGIN
    -- 커서 열기(Open)
    OPEN C1;
    -- 커서로부터 읽어온 데이터 사용(Fetch)
    LOOP
        FETCH C1 INTO REC;
        EXIT WHEN C1%NOTFOUND; -- NOTFOUND는 FETCH문에서 행을 추출하면 FALSE, 추출하지 않으면 TRUE를 반환
        DBMS_OUTPUT.PUT_LINE(REC.DEPTNO || REC.DNAME ||  REC.LOC);
    END LOOP;
    -- 커서 닫기(Close)
    CLOSE C1;
    
END;
/
-- FOR LOOP 
DECLARE
    CURSOR C1 IS (SELECT * FROM DEPT);
    REC DEPT%ROWTYPE;
BEGIN
    -- 커서 FOR LOOP 시작 (자동 OPEN, FETCH, CLOSE)
    FOR REC IN C1 LOOP
        DBMS_OUTPUT.PUT_LINE(REC.DEPTNO || REC.DNAME ||  REC.LOC);
    END LOOP;
    
END;
/
```
+ 파라미터
```
DECLARE
    CURSOR C1(P DEPT.DEPTNO%TYPE) IS (SELECT * FROM DEPT WHERE DEPTNO = P);
    REC DEPT%ROWTYPE;
BEGIN
    OPEN C1(10);
    LOOP   
        FETCH C1 INTO REC;
        EXIT WHEN C1%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(REC.DEPTNO || ' ' || REC.DNAME ||  REC.LOC);
    END LOOP;
    CLOSE C1;
    
END;
/

-- 커서에 사용할 파라미터 입력 받기
DECLARE
    CURSOR C1(P DEPT.DEPTNO%TYPE) IS (SELECT * FROM DEPT WHERE DEPTNO = P);
    REC DEPT%ROWTYPE;
    V_DEPTNO DEPT.DEPTNO%TYPE;
BEGIN
    V_DEPTNO := &INPUT_DEPTNO;
    OPEN C1(V_DEPTNO);
    LOOP   
        FETCH C1 INTO REC;
        EXIT WHEN C1%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(REC.DEPTNO || ' ' || REC.DNAME ||  REC.LOC);
    END LOOP;
    CLOSE C1;
    
END;
/

DECLARE
    CURSOR C1(P DEPT.DEPTNO%TYPE) IS (SELECT * FROM DEPT WHERE DEPTNO = P);
    REC DEPT%ROWTYPE;
    V_DEPTNO DEPT.DEPTNO%TYPE;
BEGIN
    V_DEPTNO := &INPUT_DEPTNO;
    FOR REC IN C1(V_DEPTNO)LOOP   
        DBMS_OUTPUT.PUT_LINE(REC.DEPTNO || ' ' || REC.DNAME ||  REC.LOC);
    END LOOP;
END;
/

-- SYS_REFCURSOR: 커서를 사용하는 것보다 더 효율적인 방법.
DECLARE
    -- CURSOR C1(P DEPT.DEPTNO%TYPE) IS (SELECT * FROM DEPT WHERE DEPTNO = P);
    V_DEPT SYS_REFCURSOR;
    
    REC DEPT%ROWTYPE;
    V_DEPTNO DEPT.DEPTNO%TYPE;
BEGIN
    V_DEPTNO := &INPUT_DEPTNO;
    OPEN V_DEPT FOR
        SELECT * FROM DEPT WHERE DEPTNO = V_DEPTNO;
    LOOP
        FETCH V_DEPT INTO REC;
        EXIT WHEN V_DEPT%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(REC.DEPTNO || ' ' || REC.DNAME ||  REC.LOC);
    END LOOP;
END;
/

DECLARE
    -- CURSOR C1(P DEPT.DEPTNO%TYPE) IS (SELECT * FROM DEPT WHERE DEPTNO = P);
    V_DEPT SYS_REFCURSOR;
    
    REC DEPT%ROWTYPE;
    V_DEPTNO DEPT.DEPTNO%TYPE;
BEGIN
    -- V_DEPTNO := &INPUT_DEPTNO;
    OPEN V_DEPT FOR
        SELECT * FROM DEPT; -- WHERE DEPTNO = V_DEPTNO;
    LOOP
        FETCH V_DEPT INTO REC;
        EXIT WHEN V_DEPT%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(REC.DEPTNO || ' ' || REC.DNAME ||  REC.LOC);
    END LOOP;
END;
/
```
## 예외처리
```
SET SERVEROUTPUT ON;
DECLARE
    V_WRONG NUMBER;
BEGIN
    -- DNAME과 V_WRONG은 자료형이 다르다.
    SELECT DNAME INTO V_WRONG
    FROM DEPT WHERE DEPTNO = 10;
EXCEPTION
    WHEN VALUE_ERROR THEN
        DBMS_OUTPUT.PUT_LINE('예외 처리 : 수치 또는 값 오류 발생2');
END;
/
```









# Re
[DO IT! 오라클로 배우는 데이터베이스 입문]()
