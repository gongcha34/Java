# 객체지향 프로그래밍
> 객체지향이론의 기본 개념은 '세계는 사물로 구성되어 있고, 발생하는 모든 사건들은 사물들의 상호작용이다'라고 한다. 
객체지향언어는 기존의 프로그래밍 언어에서 규칙을 추가해 보다 발전된 형태이며 객체 지향 언어의 주요특징은 아래와 같다.

## 1. 객체지향 언어
+ 코드의 재사용성이 높다
+ 코드의 관리가 용이하다
+ 신뢰성이 높은 프로그래밍이 가능하다.

## 2. 클래스와 객체
> 클래스는 '객체를 정의, 생성'하는 역할을 한다. 클래스는 객체의 설계도이다.

### 객체와 인스턴스
> 클래스로부터 만들어진 객체를 인스턴스라고 한다.

인스턴스는 객체와 같은 의미이지만 객체는 인스턴스들을 대표하는 포괄적인 의미를 갖고있고, 
인스턴스는 구체적인 클래스로부터 만들어진 객체를 강조하는 의미를 갖고 있다.

### 객체
> 객체의 구성요소는 속성(멤버변수)과 기능(메서드)이며 멤버라고 부른다.

### 인스턴스의 생성과 사용
<pre>
<code> 
  Tv t;           // Tv클래스 타입의 참조변수 선언
  t = new Tv();   // Tv 인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
</code>
</pre>

### 클래스 메서드(static메서드)와 인스턴스 메서드
> 클래스 메서드는 객체를 생성하지 않아도 '클래스이름.메서드이름(매개변수)'식으로 호출이 가능하다 , 반면에 인스턴스 메서드는 인스턴스를 생성해야만 호출할 수 있다.

+ 클래스 생성시 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것은 static을 붙인다.
+ 클래스 변수는 인스턴스를 사용하지 않아도 된다.
+ 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
+ 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

<pre>
<code>
class MemberCall{
    int iv = 10;
    static int cv = 20;

    int iv2 = cv;
    /* static int cv2 = iv;  
    non-static variable iv cannot be referenced from a static context */
    static int cv2 = new MemberCall().iv;

    static void staticMethod1() {
      System.out.println(cv);
      // System.out.println(iv); 클래스 메서드에 인스턴스 변수 사용 불가
      MemberCall c = new MemberCall();
      System.out.println(c.iv);
    }

    void instanceMethod1() {
      System.out.println(cv);
      System.out.println(iv);
    }

    static void staticMethod2() {
      staticMethod1();
      // instanceMethod1(); 클래스메서드에 인스턴스메서드 호출 불가
      MemberCall c = new MemberCall();
      c.instanceMethod1();
    }

    void instanceMethod2() {
      staticMethod1();
      instanceMethod1();
    }

}
</code>
</pre>

### 객체 배열
> 많은 수의 객체를 다뤄야 할 때, 배열로 다루면 편리하다.
> 객체 역시 배열로 다루는 것이 가능하며, 이를 '객체 배열'이라고 한다.
> 객체 배열 안에 객체가 저장 되는 것이 아닌, 객체 주소가 저장된다.
> 사실 객체 배열은 참조변수들을 하나로 묶은 참조 변수 배열인 것이다.

+ 객체 배열을 생성하는 것은, 객체를 다루기 위한 참조 변수들이 만들어진 것일 뿐, 아직 객체가 저장되지 않았다. 객체를 생성해서 객체 배열의 각 요소에 저장하는 것을 잊으면 안 된다.

<pre>
	<code>
		Tv[] tvArr = new Tv[3];
				
		tvArr[0] = new Tv();
		tvArr[1] = new Tv();
		tvArr[2] = new Tv();
	</code>
</pre>

또는 배열의 초기화 블럭을 사용하면, 다음과 같이 한 줄로 간단히 할 수 있다.

<pre>
	<code>
		Tv[] tvArr = {new Tv(),new Tv(),new Tv()};
	</code>
</pre>


## 3. 변수와 메서드
### 선언위치에 따른 변수의 종류
1. 클래스 변수 (클래스 영역 / 클래스가 메모리에 올라갈 때)
2. 인스턴스 변수 (클래스 영역 / 인스턴스가 생성되었을 때)
: 인스턴스변수와는 달리, 클래스 변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다.
3. 지역 변수 (변수 선언문이 수행되었을 때)
: 메서드 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 조욜되면 소멸되어 사요할 수 없게 된다.

<pre>
	<code>
		public class CardTest {
			public static void main(String[] args) {
				System.out.println("Card. width = "+ Card.width);
				System.out.println("Card. height = "+ Card.height);
				
				Card c1 = new Card();
				c1.kind = "Heart";
				c1.number = 7;
				
				Card c2 = new Card();
				c1.kind = "Spade";
				c1.number = 4;
				
				System.out.println("c1은 " + c1.kind + ", " + c1.number + "이며, 크기는 (" + c2.width + ", " + c1.height + ") ");
				System.out.println("c2은 " + c2.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c1.height + ") ");
				
				System.out.println("c1의 width와 height를 각각 50, 80으로 변경합니다.");
				c1.width = 50;
				c1.height = 80;
				
				System.out.println("c1은 " + c1.kind + ", " + c1.number + "이며, 크기는 (" + c2.width + ", " + c1.height + ") ");
				System.out.println("c2은 " + c2.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c1.height + ") ");
			}
		}
		
		class Card {
			String kind;
			int number;
			static int width = 100;
			static int height = 250;
		}
	</code>
</pre>

인스턴스변수는 인스턴스가 생성될 때 마다 생성쇠므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갇는다.

### 메서드
> '메서드(method)'란 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.

####메서드를 사용하는 이유
+ 높은 재사용성
+ 중복된 코드의 제거
+ 프로그램의 구조화

### JVM의 메모리 구조
> 응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
> 주요 영영은 method area, call stack, heap이 있다.

1. 메서드 영역 : 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일을 읽어서 분석하여 클래스에 대한 정보를 이곳에 저장한다. 그 클래스의 클래스변수도 이 영역에 함께 생성된다.
2. 힙 : 인스턴스가 생성되는 공간, 인스턴스 변수들이 생성되는 공간이다.
3. 호출스택 : 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 메서드가 작업을 마치면 메모리 공간은 반한되어 비워진다.

### 기본형 매개변수와 참조형 매개변수
> 자바에서는 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다.
> 매개변수의 타입이 기본형일 때는 기본형 값이 복사되지만, 참조형이면 인스턴스의 주소가 복사된다.

기본형 매개변수는 벼수의 값을 읽기만 할 수 있고 참조형 매개변수는 변수의 값을 읽고 변경할 수 있다.

## 4. 오버로딩
> 자바에서는 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 개수와 타입이 다르면 같은 이름을 사용해서 메서드를 정의할 수 있다

오버로딩 조건
1. 메서드는 이름이 같아야 한다.
2. 매개변수 개수 또는 타입이 달라야 한다.

(주의) 반환타입은 오버로딩에 영향을 주지 않는다.

오버로딩의 장점은 이름 짓기가 쉽고 기억하기 편리하며, 오류 가능성을 줄일 수 있다.

## 가변인자 (Variable arguments)
> 매개 변수의 개수를 동적으로 지정할 수 있다.

(주의) 
1. 가변인자는 제일 마지막에 선언되어야 한다.
2. 오버로딩된 메서드가 구분이 안될 경우 컴파일에러가 발생한다. (가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋다.)

## 생성자
> 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'

1. 인스턴스 변수의 초기화 작업
2. 인스턴스 생성시에 실행되어야 할 작업을 위해서 사용된다.

생성자의 조건
1. 생성자의 이름은 클래스 이름과 같아야한다.
2. 리턴값이 없다.
3. 오버로딩이 가능해서 하나의 클래스에 여러개의 생성자가 존재할 수 있다.

+ 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.
	+ 연산자 new에 의해서 메모리(heap)에 인스턴스가 생성된다
	+ 생성자가 호출되어 수행된다
	+ 연산자 new의 결과로, 생성된 인스턴스의 주소가 반환되어 참조변수에 저장된다.

기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 없는 경우이다.

## 변수의 초기화
> 멤버변수 (클래스변수, 인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.

멤버변수의 초기화 방법
1. 명시적 초기화 (변수선언과 동시에 초기화)
2. 생성자
3. 초기화 블럭 (인스턴스 초기화 블럭, 클래스 초기화 블럭)

# *Reference
+ [Java의 정석](http://www.yes24.com/Product/Goods/24259565?OzSrank=1)


