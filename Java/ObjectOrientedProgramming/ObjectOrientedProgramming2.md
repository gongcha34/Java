# 객체지향 프로그래밍 2
## 1. 상속(Inheritance)
> 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 

### 상속 정의와 장점
1. 적은 양의 코드로 새로운 클래스를 작성할 수 있고, 코드를 공통적으로 관리하기 때문에 코드의 추가 및 변경이 매우 용이하다.
2. 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.

자바에서 상속을 구현하는 방법
<pre>
	<code>
		class Child extends Parent {
			// 상속해주는 클래스를 조상클래스, 상속 받는 클래스를 자손 클래스라한다.
		}
	</code>
</pre>

+ 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
+ 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
+ 전체 프로그램을 구성하는 클래스들을 면밀히 설계 분석하여, 클래스간의 상속관계를 적절히 맺어 주는 것이 객체지향 프로그래밍에서 가장 중요한 부분이다.
+ 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

### 클래스간의 관계 - 포함관계
> 상속이외에도 클래스를 재사용하는 또 다른 방법이 있는데, 그게 바로 클래스간에 '포함'관계이다.
> 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언한다.

### 클래스간의 관계 결정하기
상속관계: ...은 ~이다(is-a)
포함관계: ...은 ~을 가지고 있다(has-a)

### 단일 상속
> 자바에서는 오직 단일 상속만을 허용한다. 둘 이상의 클래스로부터 상속을 받을 수 없다.

### Object클래스 - 모든 클래스의 조상
> Object클래스는 모든 클래스 상속게층도의 최상위에 잇는 조사클래스이다. 모든 클래스들은 자동적으로 Object클래스로부터 상속받는다.

자바의 모든 클래스들은 Object클래스의 멤버들을 상속 받기 때문에 Object클래스에 정의된 멤버들을 사용할 수 있다.

## 2. 오버라이딩(overriding)
> 상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스 자신에 맞게 변경해야하는 경우가 많다. 이럴 때 조상의 메서드를 오버라이딩한다.

### 오버라이딩의 조건
자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
- 이름이 같아야 한다.
- 매개변수가 같아야 한다.
- 반환타입이 같아야 한다.
다만 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
	접근 제어자의 접근범위를 나열하면 public>protected>(default)>private이다
2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

### 오버로딩 vs. 오버라이딩
오버로딩 :  기존에 없는 새로운 메서드를 정의하는 것 (new)
오버라이딩 : 상속받은 메서드의 내용을 변경하는 것(change, modify)

### super
> super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.
> 멤버변수와 지역변수의 이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별한다.

+ 조상 클래스의 멤버와 자손 클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우에만 쓰는게 좋다.
+ static 메서드는 인스턴스와 관련이 없다. 그래서 this와 마찬가지로 super역시 static메서드에서는 사용할 수 없고 인스턴스메서드에서만 사용할 수 있다.

### super() - 조상 클래스의 생성자
> this()와 마찬가지로 super() 역시 생성자이다. this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만, super()는 조상 클래스의 생서자를 호출하는데 사용된다.

Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자,this() 또는 super(),를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 super();를 생성자의 첫줄에 삽입한다.

1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
2. 생성자 - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?

## 3. package와 import
### 패키지(package)
> 패키지란, 클래스의 묶음이다.
> 패키지에는 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 다누이로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.

+ 같은 이름의 클래스 일지라도 서로 다른 패키지에 존재하는 것이 가능하다.
+ 클래스의 실제 이름(full name)은 패키지명을 포함한 것이가
+ 클래스가 물리적으로 하나의 클래스파이(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.

- 하나의 소스파일에는 첫 번째 무장으로 단 한 번의 패키지 선언만을 허용한다.
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점(.0을 구분자로 하여 계층구조로 구성할 수 있다.
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.

### 패키지의 선언
> 하나의 소스파일에 단 한번만 선언될 수 있다.

<pre>
	<code>
		package 패키지명;
	</code>
</pre>

### import문
> 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다.
> 하지만, 매법 패키지명을 붙여서 작성하기는 불편하기 때문에 클래스의 코드를 작성하기 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 패키지명은 생략할 수 있다.

일반적인 소스파일(*.java)의 구성은 다음의 순서로 되어 있다.
1. package문
2. import문
3. 클래스 선언

### static import문
> static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.

## 4. 제어자
### 제어자란?
> 제어자는 클래스, 변수 또는 메서드의 선언부와 함께 사용되어 부가적인 의미를 부여한다. 제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.

접근 제어자: public, protected, default, private
그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp

하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.
단, 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다.

### static -클래스의, 공통적인
> 하나의 변수를 모든 인스턴스가 공유하기 때문에 클래스 변수는 인스턴스에 관계없이 같은 값을 갖는다.
> static이 붙은 멤버 변수와 메서드, 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.

사용될 수 있는 곳: 멤버변수, 메서드, 초기화 블럭

### final - 마지막의, 변경될 수 없는
> 변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게 되고, 클래스에 사용되면 자신의 확장하는 자손클래스를 정의하지 못하게 된다.

사용될 수 있는 곳: 클래스, 메서드, 메버변수, 지역변수

#### 생성자를 이용한 final멤버 변수의 초기화
> final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다.

### abstract - 추상의, 미완성의
> 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.
> 클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 한다.

사용될 수 있는 곳: 클래스, 메서드

### 접근 제어자
> 접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.

#### 접근 제어자를 이용한 캡슐화
> 클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.
> 클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 멤버변수나 부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에 감추기 위해서다.

#### 생성자의 접근 제어자
> 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.

생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다.
그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.
대신 인스턴스를 생성해서 반환해주는 public 메서드를 제공함으로써 외부에서 이 클래스의 인스턴스를 사용하도록 할 수 있다.

# *Reference
+ [Java의 정석](http://www.yes24.com/Product/Goods/24259565?OzSrank=1)




